# Scale-Invariant-Feature-Transform
INTRODUCTION
*	Blob detection refers to visual modules that are aimed at detecting points or regions in the image that are either brighter or darker than the surrounding.
*	In order to automatically detect blobs of different sizes, a multiscale approach is necessary. 
*	According to the scale-space theory the  multiple-scale LoG blob detector can locate blobs of different scales by detecting local extrema of the LoG scale-space representation after the scale-normalized LoG operation, where the scale of the detected blob is determined by selecting the one at which  the maximum ﬁlter response is assumed

Algorithm and Program outline:
*)	Generating a Laplacian of Gaussian filter
+)	The Log filter is generated using the equation:
          
(Where, (x,y) are the coordinates of the kernel,  where x goes from –M/2 to M/2 and y goes from –    N/2 to N/2. (M,N)=size of kernel.(In this program only odd sized kernels are used). Sigma=standard deviation of Gaussian.)
+)	This kernel is generated by the function defined as : coeff(size,s)

+)	The function takes in the size of kernel and sigma(s) as input and outputs the kernel matrix.
*)	Laplacian Scale space
The following steps are performed 12 times to get 12 layers in the Laplacian scale space.
+)	The initial scale is taken as k=1.32  and Initial sigma=2.
+)	The kernel is obtained using coeff(size,s) function for given sigma and size
Size of kernel=2*ceil(sigma*3)+1

+)	Normalized Laplacian is obtained as sigma^2 times the above kernel.
+)	Filtering:
The image is filtered with the kernel obtained above. This is done using the modified function from project2. The out=frequency_filter(image,kernel) function performs convolution in the frequency domain. This is done in the following steps:
*	The functions takes image and kernel as inputs.
*	2-D DFT is performed on the image using the defined function D_2_fft(image).
*	Make the kernel size equal to size of image by zero padding and using ifftshift.
*	2-D DFT is performed on the new kernel using D_2_fft() function.
*	The 2 DFTs are multiplied and inverse dft is taken from 2_D_fft function to obtain the filtered image.
+)	The Laplacian obtained is squared and saved in a 3D scale space.
+)	Sigma is increased by a scale of k for each iteration
+)	The above steps are performed for n=12 iterations to obtain 12 layers in the laplacian scale space.
+)	Non Maxima Supression
*)	The maxima is calculated for each element of the matrix with respect to the eight neighbours.
*)	This max element is calculated for all 12 laplacian scale space layers.
*)	Maximum  value of each pixel is calculated considering all the layers(in the 3D scale space).
*)	We obtain a matrices of 0s and max values using the maximum values created above for all the twelve 3D scale spaces.

*.) Displaying circles to represent the blobs 
+)	 The non-maxima values are replaced by 0  and others by using a threshold=0.007 for all         the layers in the scale space.
+)	 The radius is calculated for different values of sigma as r=1.414*sigma and stored.
+)	The coordinates of maxima are found and stored.
+)	The values of coordinates of the center of maxima on the image and the radius of the       circle is used to draw the circles using the function defined as show_all_circles(I,cx,cy,rad), where I=image( cx,cy)
